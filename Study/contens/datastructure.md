# __DataStructure__

**:book: contents**
* 그래프(Graph)

---

### __그래프(Graph)__
#### 인접 행렬과 인접 리스트

##### 01. 인접 행렬

`인접 행렬`은 그래프의 연결 관계를 이차원 배열로 나타내는 것을 말한다. 인접 행렬을 adj[i][j]로 나타낸다면 다음과 같은 의미를 가지고 있다.
> adj[i][j] = i 노드에서 j 노드로 가는 간선(edge) 있다면 1, 없으면 0

`인접 행렬의 장점`은 구현이 쉽다는 점이다. 또한 노드 i 와 j 가 연결 되어 있는지 확인하기 위해서 `adj[i][j]`의 값만 확인하면 되므로 O(1)의 시간복잡도를 가지게 된다.  
`하지만 단점`도 존재한다. 만약 노드의 수를 n, 간선의 수를 m이라 할 때 노드 i 와 연결되어 있는 모든 노드를 확인하고 싶다면 adj[i][1] = adj[i][n]를 모두 검색해야 하기 때문에 O(n)의 시간이 걸리게 된다. 또한 전체 노드를 탐색하고 싶다면 O(n^2)의 시간이 걸리게 된다는 단점이 존재한다.

##### 02. 인접 리스트

`인접 리스트`는 그래프의 연결 관계를 LinkedList로 나타내는 방법이다. java로 나타내면 `LinkedList<Integer>[] adj` 로 나타낼 수 있다. 인접 리스트를 adj[i]로 나타낸다면 다음과 같은 의미를 가지고 있다.
> adj[i] = i 노드에 연결 된 노드의 번호를 가진 연결리스트

`인접 리스트의 장점`은 실제 연결 된 노드들의 정보만을 저장하기 때문에 `간선의 개수에 비례하는 메모리만 차지`한다는 장점이 있다. 또한 노드 i 와 연결되어 있는 모든 노드를 확인하기 위해선 adj[i][0] ~ adj[i][size]까지만 확인하면 된다는 장점이 있다. 또한 연결된 모든 노드를 반복하기 위해서 O(n + m)의 시간 복잡도만을 이용해 전체를 탐색 할 수 있다.  
`하지만 단점`도 존재한다. 만약 노드 i와 j가 서로 연결 되어 있는지 확인하기 위해서는 adj[i]의 연결리스트에 j를 원소로 갖는지 확인해야 한다. 이는 인접행렬의 O(1)보다 더 많은 시간이 소요된다.
