# :book: Docker

* [도커 이미지](#도커-이미지)
* [도커 컨테이너](#도커-컨테이너)
* [컨테이너 생성](#컨테이너-생성)
* [컨테이너 목록 확인](#컨테이너-목록-확인)
* [컨테이너 삭제](#컨테이너-삭제)
***
:bulb: 도커 엔진에서 사용하는 기본 단위는 `이미지`와 `컨테이너`이며, 이 두 가지가 **도커 엔진의 핵심이다.**

### **도커 이미지**
컨테이너를 생성할 때 필요한 요소이며 `우분투`, `CentOS`, `아파치 웹 서버`, `MySQL`, `하둡(Hadoop)`, `스파크(Spark)` 등 다양한 종류가 있다.
* 여러 개의 계층으로 된 바이너리 파일로 존재한다.
* 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다.

도커에서 사용하는 이미지의 이름은 기본적으로 **[저장소 이름]/[이미지 이름]:[태그]** 형태로 구성되어 있다.

    ex.) alicek106/ubuntu:16.04     [저장소 이름]/[이미지 이름]:[이미지 버전]
    ex.) ubuntu/latest      [이미지 이름]:[이미지 버전]

* 저장소(Repository) : 이미지가 저장된 장소, 저장소 이름이 명시되지 않은 이미지는 **도커에서 기본적으로 제공하는 이미지 저장소인 도커 허브(Docker Hub)의 공식(Official) 이미지를 뜻한다.**
* 이미지 이름 : 이미지가 어떤 역할을 하는지를 나타내며 **필수로 설정해야 한다.**
* 태그 : 이미지의 버전 관리, 혹은 리비전(Revision) 관리에 사용, 일반적으로 버전을 명시하지만 **생략할 경우 태그를 latest로 인식한다.**

### **도커 컨테이너**
이미지로 컨테이너를 생성하며 **해당 이미지의 목적에 맞는 파일이 들어있는 파일시스템**과 **격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간**

* 이미지를 읽기 전용으로 사용한다.
* **이미지에서 변경된 사항만 컨테이너 계층에 저장하므로** 원래 이미지는 영향을 받지 않는다.
* 생성된 각 컨테이너는 **각기 독립된 파일시스템을 제공**받으며 **호스트와 분리되어 있다**

### **컨테이너 생성**

:heavy_check_mark: 컨테이너 생성 및 실행
```go
docker run : 컨테이너를 생성하고 실행한다. 실행과 동시에 내부로 들어감
docker create : 컨테이너를 생성함
docker start : 컨테이너를 실행함
docker attach : 컨테이너의 내부로 들어감
```
:heavy_check_mark: 옵션
```go
-i : 상호 입출력 설정
-t : tty 활성화해서 bash shell을 사용하도록 설정
-d : Detached 모드로 컨테이너 실행 (컨테이너를 백그라운드에서 동작하는 애플리케이션으로 실행하도록 설정)
-e : 컨테이너 내부의 환경변수 설정
--link : 내부 IP를 알 필요 없이 항상 컨테이너에 별명(alias)로 접근하도록 설정
--name : 컨테이너의 이름을 설정
--rename : 컨테이너 이름 변경
```
:heavy_check_mark: 컨테이너 빠져나오기
```go
exit 또는 Ctrl + D : 컨테이너를 빠져옴과 동시에 컨테이너 정지
Ctrl + P, Q : 단순히 컨테이너의 셸만 빠져나옴
```
:heavy_check_mark: 이미지 관련
```go
docker pull : 이미지 내려받기
docker images : 도커 엔진에 존재하는 이미지의 목록 출력
```

### **컨테이너 목록 확인**
:heavy_check_mark: 컨테이너 목록 확인
```go
docker ps : 호스트에서 지금까지 생성한 컨테이너 목록을 확인 (정지되지 않은 컨테이너)
```
:heavy_check_mark: 옵션
```go
-a : 정지된 컨테이너까지 포함해 출력
-q : 컨테이너의 ID만 출력
```

### **컨테이너 삭제**
컨테이너 삭제는 `정지된 상태`가 아니면 삭제할 수 없다. 삭제하기 위해선 **컨테이너를 정지 후 삭제** 하거나 `-f` 옵션을 줘야 한다.

:heavy_check_mark: 컨테이너 삭제
```go
docker rm : 컨테이너를 삭제함
docker stop : 실행중인 컨테이너를 정지함
docker container prune : 모든 컨테이너를 삭제함
docker stop $(docker ps -a -q) : 모든 컨테이너를 정지함
docker rm $(docker ps -a -q) : 모든 컨테이너를 삭제함
```

:bulb: 한 번 삭제한 컨테이너는 복구할 수 없다 :bangbang:

:heavy_check_mark: exec 컨테이너 명령어 실행
실행중인 컨테이너에 들어가 보거나 컨테이너 파일을 실행하고 싶을 때 사용하는 명령어
```go
docker  exec [OPTION] CONTAINER COMMAND [ARG...]

ex ) docker exec -i -t wordpressdb /bin/bash
```
wordpressdb 컨테이너 내부에 /bin/bash 프로세스를 실행하고 -i -t 옵션을 이용해 배시 셸을 쓸 수 있게 된다

### **도커 볼륨**
컨테이너의 데이터를 영속적( Persistent ) 데이터로 활용할 수 있는 방법중 가장 활용하기 쉬운 방법.

이미 생성된 이미지는 **어떤 경우로도 변경되지 않는다.** 컨테이너 계층에 원래 이미지에서 변경된 파일시스템 등을 저장.

     이미지에 mysql을 실행하는데 필요한 애플리케이션 파일이 들어있다면  
     컨테이너 계층에는 워드프레스에서 쓴 로그인 정보나 게시글 등과 같이  
     데이터베이스를 운용하면서 쌓이는 데이터가 저장됨

:bangbang: 하지만 mysql 컨테이너는 삭제하면 **컨테이너 계층에 저장돼있던 데이터베이스의 정보도 삭제된다는** 치명적인 단점이 존재한다. **따라서,** 이러한 문제점을 해결하기 위해 **도커 볼륨을** 활용한다. 활용하는 방법은 세 가지가 있다.

* 호스트 볼륨 공유
* 볼륨 컨테이너
* 도커 볼륨

:heavy_check_mark: -v 디렉터리 공유
```go
-v [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리]

ex) -v /home/wordpress_db:/var/lib/mysql
```
컨테이너의 공유 디렉터리는 호스트의 디렉터리와 동기화 되는 것이 아니라 **완전히 같은 디렉터리 이다.**
