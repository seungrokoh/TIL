# __관계형 데이터 모델링(RDB)__

**업무파악** -> **개념적 데이터 모델링** -> **논리적 데이터 모델링** -> **물리적 데이터 모델링**

***

# __업무 파악__
어떤 것을 꿈꾸고 있는지, 어떤 결과물을 만들어내고 싶은지를 파악하는 단계 (기획서 또는 UI)
* 원하는 결과물을 함께 고민하고 그려가며 UI를 설계해본다.
* 서로 고민하며 원하는 결과물을 구체화시킬 수 있다.

__@TODO__
__원하는 결과물을 기획하기__
[ovenapp](https://ovenapp.io/)을 이용해 결과물을 만들어보기

***

# __개념적 데이터 모델링__
내가 하고자 하는 일이 어떠한 개념들을 가지고 있고 상호작용하고 있는지 생각하는 단계  
이 과정에서 ER-다이어그램을 뽑아낼 수 있다.

* 현실에서 개념을 추출하는 일종의 **필터**를 제공한다.
* 개념에 대해서 다른사람들과 대화할 수 있게 해주는 일종의 언어로서 작용하게 된다.
* 이를 이루게 해주는 것이 **Entity Relationship Diagram(ERD)** 이다.

> 포함적인 관계가 아닌 평면적인 관계로 개념을 뽑아낸다.

## __Entity Relationship Diagram__
현실을 3가지 관점으로 간단하게 바라볼 수 있는 **Finder와 같은 역할을 한다.** 현실로부터 개념을 인식하는 도구 이면서 다른사람도 알아볼 수 있게 해줄 수 있게 해준다. **또한 매우 쉽게 표로 전환할 수 있다.**

#### __ERD의 3가지 관점__
1. 정보 - 정보를 발견하고 다른사람에게 표현할 수 있게 해준다.
2. 그룹 - 서로 연관된 정보를 그룹핑해서 인식하고 다른사람에게 표현할 수 있게 해준다.
3. 정보 그룹사이의 관계를 인식하고 다른사람에게 표현할 수 있게 해준다.

#### __ERD를 만드는 방법__
1. 서로 연관된 정보들을 묶어주는 큰 덩어리부터 뽑아낸다. (ex. 글, 저자, 댓글 등)
2. 글, 저자, 댓글 들을 모두 동등하게 표현한다.
3. 표 안에 표가 내포되어 있는 관계는 허용하지 않는다.

__[표 1. 거대 단일 테이블]__
|글 제목|글 내용|글 저자 이름|글 저자 소개|글 저자 가입일|댓글 내용|댓글 저자|댓글 저자 소개|댓글 저자 가입일|
|---|---|---|---|---|---|---|---|---|
|글 1 제목|글 1 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개|<div style="background:yellow;">저자 1 가입일|댓글 1 내용|<div style="background:yellow;">저자 1 이름|<div style="background:yellow;">저자 1 소개|<div style="background:yellow;">저자 1 가입일|
|글 2 제목|글 2 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개|<div style="background:yellow;">저자 1 가입일|댓글 2 내용|<div style="background:yellow;">저자 1 이름|<div style="background:yellow;">저자 1 소개|<div style="background:yellow;">저자 1 가입일|
|글 3 제목|글 3 내용|<div style="background:green;">저자 2 이름</span>|<div style="background:green;">저자 2 소개|<div style="background:green;">저자 2 가입일|댓글 3 내용|<div style="background:#20a4e6;">저자 3 이름|<div style="background:#20a4e6;">저자 3 소개|<div style="background:#20a4e6;">저자 3 가입일|

**표 1**과 같이 하나의 표 안에 모든 정보를 다 담을 수도 있다. 즉 여러개의 컬럼(Column)을 가진 표를 만들 수 있다. **하지만** 극단적으로 1천개의 컬럼이 필요한 표를 만들었을 때 불필요한 정보를 불러올 수 있다. 또한 1억개의 데이터가 있다면 **데이터의 중복이 발생**하게 된다. 즉, **거대 단일 테이블로 표현하면 데이터를 다룰 때 효율이 떨어지고 중복이 발생한다.** 이러한 중복을 최소화 하기 위해 아래와 같이 표를 나눈다.

__[표 2. 글 테이블]__

|아이디|제목|내용|저자 아이디|
|:---:|:---:|:---:|:---:|
|1|제목 1|내용 1|1|
|2|제목 2|내용 2|1|
|3|제목 3|내용 3|1|

__[표 3. 저자 테이블]__

|아이디|이름|소개|
|:---:|:---:|:---:|
|1|이름 1|소개 1|
|2|이름 2|소개 2|
|3|이름 3|소개 3|

__[표 4. 댓글 테이블]__

|아이디|제목|내용|작성일|저자 아이디|
|:---:|:---:|:---:|:---:|:---:|
|1|제목 1|내용 1|작성일 1|1|
|2|제목 2|내용 2|작성일 2|1|
|3|제목 3|내용 3|작성일 3|2|

**위와 같이 테이블을 여러개로 쪼갰을 때의 이점**
1. 주제에 따라서 데이터를 **그룹핑**할 수 있다.
2. 필요한 정보만을 뽑아낼 수 있다.
3. **Join**을 사용하여 아래 [표 5]와 같이 **관계된 테이블을 합성**하여 뽑아낼 수 있다.

> **SELECT** 댓글, 내용, 댓글.작성일, 저자.이름, 저자.소개
**FROM** 댓글 **LEFT JOIN** 저자 **ON** 댓글.저자 아이디 = 저자.아이디

__[표 5. Join 결과]__
|댓글 내용|댓글 작성일|저자|저자 소개|
|:---:|:---:|:---:|:---:|
|댓글 1 내용|댓글 1 작성일|<div style="background:green;">저자 1 이름|<div style="background:green;">저자 1 자기소개|
|댓글 2 내용|댓글 2 작성일|<div style="background:green;">저자 1 이름|<div style="background:green;">저자 1 자기소개|
|댓글 3 내용|댓글 3 작성일|<div style="background:green;">저자 1 이름|<div style="background:green;">저자 1 자기소개|

> 포함적인 관계가 아닌 평면적인 관계로 개념을 뽑아낸다.

### __ERD 에서의 표현__
#### __Entity - Table__
찾아낸 **개념을 Entity**라고 말하며 추후 Table로 전환이 된다.

    개념 : 글, 저자, 댓글 등

#### __Attribute - column__
개념안에 있는 **구체적인 데이터**를 말하며 추후 Table의 Column이 된다.

    구체적 데이터 : 글(개념)의 제목, 본문, 생성일 등

Entity를 Directory라고 생각하고 Attribute를 File이라고 한다면  Entity는 Child Directory를 가질 수 없는 **평면적인 Directory**라고 생각하면 된다.

#### __Relation - PK, FK__
**Entity들 간의 연관성을 표현**해 준 것을 Relation 이라고 하며 PK, FK의 형태로 관계가 표현이 되며 **Join을 통해 테이블들을 연결**한다.

    저자 --- <쓰다> --- 글
    글 --- <소속> --- 댓글
    저자 --- <쓰다> --- 댓글

# __논리적 데이터 모델링__
생각한 개념들을 관계형 데이터 베이스 패러다임에 맞는 표로 전환하는 작업

# __물리적 데이터 모델링__
어떤 데이터베이스를 사용할 것인지 생각하는 단계  
표를 생성하는 SQL코드를 산출할 수 있다.
