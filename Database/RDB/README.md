# __관계형 데이터 모델링(RDB)__

**업무파악** -> **개념적 데이터 모델링** -> **논리적 데이터 모델링** -> **물리적 데이터 모델링**

***

# __업무 파악__
어떤 것을 꿈꾸고 있는지, 어떤 결과물을 만들어내고 싶은지를 파악하는 단계 (기획서 또는 UI)
* 원하는 결과물을 함께 고민하고 그려가며 UI를 설계해본다.
* 서로 고민하며 원하는 결과물을 구체화시킬 수 있다.

__@TODO__
__원하는 결과물을 기획하기__
[ovenapp](https://ovenapp.io/)을 이용해 결과물을 만들어보기

***

# __개념적 데이터 모델링__
내가 하고자 하는 일이 어떠한 개념들을 가지고 있고 상호작용하고 있는지 생각하는 단계  
이 과정에서 ER-다이어그램을 뽑아낼 수 있다.

* 현실에서 개념을 추출하는 일종의 **필터**를 제공한다.
* 개념에 대해서 다른사람들과 대화할 수 있게 해주는 일종의 언어로서 작용하게 된다.
* 이를 이루게 해주는 것이 **Entity Relationship Diagram(ERD)** 이다.

> 포함적인 관계가 아닌 평면적인 관계로 개념을 뽑아낸다.

## __Entity Relationship Diagram__
현실을 3가지 관점으로 간단하게 바라볼 수 있는 **Finder와 같은 역할을 한다.** 현실로부터 개념을 인식하는 도구 이면서 다른사람도 알아볼 수 있게 해줄 수 있게 해준다. **또한 매우 쉽게 표로 전환할 수 있다.**

#### __ERD의 3가지 관점__
1. 정보 - 정보를 발견하고 다른사람에게 표현할 수 있게 해준다.
2. 그룹 - 서로 연관된 정보를 그룹핑해서 인식하고 다른사람에게 표현할 수 있게 해준다.
3. 정보 그룹사이의 관계를 인식하고 다른사람에게 표현할 수 있게 해준다.

#### __ERD를 만드는 방법__
1. 서로 연관된 정보들을 묶어주는 큰 덩어리부터 뽑아낸다. (ex. 글, 저자, 댓글 등)
2. 글, 저자, 댓글 들을 모두 동등하게 표현한다.
3. 표 안에 표가 내포되어 있는 관계는 허용하지 않는다.

__[표 1. 거대 단일 테이블]__

|글 제목|글 내용|글 저자 이름|글 저자 소개|글 저자 가입일|댓글 내용|댓글 저자|댓글 저자 소개|댓글 저자 가입일|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|글 1 제목|글 1 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개</span>|<div style="background:yellow;">저자 1 가입일</span>|댓글 1 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개</span>|<div style="background:yellow;">저자 1 가입일</span>|
|글 2 제목|글 2 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개</span>|<div style="background:yellow;">저자 1 가입일</span>|댓글 2 내용|<div style="background:yellow;">저자 1 이름</span>|<div style="background:yellow;">저자 1 소개</span>|<div style="background:yellow;">저자 1 가입일</span>|
|글 3 제목|글 3 내용|<div style="background:green;">저자 2 이름</span>|<div style="background:green;">저자 2 소개</span>|<div style="background:green;">저자 2 가입일</span>|댓글 3 내용|<div style="background:#20a4e6;">저자 3 이름</span>|<div style="background:#20a4e6;">저자 3 소개</span>|<div style="background:#20a4e6;">저자 3 가입일</span>|

**표 1**과 같이 하나의 표 안에 모든 정보를 다 담을 수도 있다. 즉 여러개의 컬럼(Column)을 가진 표를 만들 수 있다. **하지만** 극단적으로 1천개의 컬럼이 필요한 표를 만들었을 때 불필요한 정보를 불러올 수 있다. 또한 1억개의 데이터가 있다면 **데이터의 중복이 발생**하게 된다. 즉, **거대 단일 테이블로 표현하면 데이터를 다룰 때 효율이 떨어지고 중복이 발생한다.** 이러한 중복을 최소화 하기 위해 아래와 같이 표를 나눈다.

__[표 2. 글 테이블]__

|아이디|제목|내용|저자 아이디|
|:---:|:---:|:---:|:---:|
|1|제목 1|내용 1|1|
|2|제목 2|내용 2|1|
|3|제목 3|내용 3|1|

__[표 3. 저자 테이블]__

|아이디|이름|소개|
|:---:|:---:|:---:|
|1|이름 1|소개 1|
|2|이름 2|소개 2|
|3|이름 3|소개 3|

__[표 4. 댓글 테이블]__

|아이디|제목|내용|작성일|저자 아이디|
|:---:|:---:|:---:|:---:|:---:|
|1|제목 1|내용 1|작성일 1|1|
|2|제목 2|내용 2|작성일 2|1|
|3|제목 3|내용 3|작성일 3|2|

**위와 같이 테이블을 여러개로 쪼갰을 때의 이점**
1. 주제에 따라서 데이터를 **그룹핑**할 수 있다.
2. 필요한 정보만을 뽑아낼 수 있다.
3. **Join**을 사용하여 아래 [표 5]와 같이 **관계된 테이블을 합성**하여 뽑아낼 수 있다.

> **SELECT** 댓글, 내용, 댓글.작성일, 저자.이름, 저자.소개
**FROM** 댓글 **LEFT JOIN** 저자 **ON** 댓글.저자 아이디 = 저자.아이디

__[표 5. Join 결과]__

|댓글 내용|댓글 작성일|저자|저자 소개|
|:---:|:---:|:---:|:---:|
|댓글 1 내용|댓글 1 작성일|<div style="background:green;">저자 1 이름</span>|<div style="background:green;">저자 1 자기소개</span>|
|댓글 2 내용|댓글 2 작성일|<div style="background:green;">저자 1 이름</span>|<div style="background:green;">저자 1 자기소개</span>|
|댓글 3 내용|댓글 3 작성일|<div style="background:green;">저자 1 이름</span>|<div style="background:green;">저자 1 자기소개</span>|

> 포함적인 관계가 아닌 평면적인 관계로 개념을 뽑아낸다.

### __ERD 에서의 표현__
#### __Entity - Table__
찾아낸 **개념을 Entity**라고 말하며 추후 Table로 전환이 된다.

    개념 : 글, 저자, 댓글 등

#### __Attribute - column__
개념안에 있는 **구체적인 데이터**를 말하며 추후 Table의 Column이 된다.

    구체적 데이터 : 글(개념)의 제목, 본문, 생성일 등

Entity를 Directory라고 생각하고 Attribute를 File이라고 한다면  Entity는 Child Directory를 가질 수 없는 **평면적인 Directory**라고 생각하면 된다.

#### __Relation - PK, FK__
**Entity들 간의 연관성을 표현**해 준 것을 Relation 이라고 하며 PK, FK의 형태로 관계가 표현이 되며 **Join을 통해 테이블들을 연결**한다.

    저자 --- <쓰다> --- 글
    글 --- <소속> --- 댓글
    저자 --- <쓰다> --- 댓글

***
## **Entity 정의**
**읽기**에서는 Entity를 찾기가 힘들고 **쓰기**에서는 대체적으로 찾기 쉽다. 즉, 예제에서 살펴보면 **저자등록, 글 작성, 댓글 작성** 등이 쓰기에 해당한다.

__~~@TODO~~__
__~~ER-Diagram 그려보기~~__
~~[draw.io](https://www.draw.io)를 이용해 ER-Dialgram 그려보기~~

## **각 Entity에서 속성 뽑아내기**
* 글 - 제목, 작성일, 본문
* 저자 - 이름, 자기소개, 가입일
* 댓글 - 본문, 작성일

각 Entity의 속성들을 정의 했다면 식별자(Identifier)를 설정해줘야 한다. **식별자란 해당 Entity의 Raw를 나타내는 고유 속성**이며 추후 PrimaryKey가 된다.

**식별자로 사용될 수 있는 Column**
중복이 발생할 수 없는 속성(Column)을 식별자로 선정해야 한다.

* 후보키(candidate key) - 식별자가 될 수 있는 key들
* 기본키(primary key) - 후보키 중에서 선정한 식별자
* 대체키(alternate key) - 기본키가 아닌 후보키들 (성능향상을 위해서 secondary index를 걸기 좋은 key)
* 중복키(composite key) - 두개의 key를 합쳐 기본키로 설정함

식별자를 선정하기 위해 각 Entity에 Primary Key가 될 수 있는 속성을 추가함.

* 글 - **글 아이디(auto increasement)**, 제목, 작성일 본문
* 저자 - **저자 아이디(auto increasement)**, 자기소개, 가입일
* 댓글 - **댓글 아이디(auto increasement)**, 본문, 작성일

***
## **Relationship 정의**
각 테이블들의 **PrimaryKey와 ForeignKey가 연결**되는 걸 통해서 실제로 구현이 된다.

    PrimaryKey - 각 테이블의 Raw를 식별하는 유일무일한 식별자
    ForeignKey - 다른 테이블의 PrimaryKey와 연결되어 있는 식별자

### __Cardinality와 Optionality__

**Cardinality**
ERD에서 데이터베이스가 지켜야할 제약조건 중 연결(Connectivity)를 나타내는 것

    일대일(One To On, 1:1) - X에 속하는 한 개체는 Y에 속하는 한 개체에만 연결되며, Y에 속하는 한 개체도 X에 속하는 한 개체에만 연결된다.(ex. 담임 - 반)
    일대다(One To Many, 1:N) - X에 속하는 한 개체는 Y에 속하는 한 개체에만 연결되며, Y에 속하는 한 개체는 X에 속하는 여러 개체들과 연결된다. (ex. 저자 - 댓글)
    다대다(Many To Many, N:N) - X에 속하는 한 개체는 Y에 속하는 여러 개체들과 연결될 수 있으며, Y에 속하는 한 개체도 X에 속하는 여러 개체들과 연결될 수 있다. (ex. 글 - 저자 (공동 저자))

__Optionality__
ERD에서 두 테이블간 필수관계(Mandatory)와 선택관계(Optional)를 나타내는 것

    Ex) 저자 - 댓글간의 관계
    저자의 관점 - 저자는 댓글을 작성하지 않을수도 있다.
    댓글의 관점 - 각 댓글은 반드시 저자가 있다.

    표현 (ㅁ - 테이블)
    ㅁ--|-----O--ㅁ

## __ER-Diagram__
![ER-Diagram](./images/ER_Diagram.png)
# __논리적 데이터 모델링__
생각한 개념들을 관계형 데이터 베이스 패러다임에 맞는 표로 전환하는 작업

# __물리적 데이터 모델링__
어떤 데이터베이스를 사용할 것인지 생각하는 단계  
표를 생성하는 SQL코드를 산출할 수 있다.
